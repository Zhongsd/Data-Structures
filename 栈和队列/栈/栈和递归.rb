def factorial(n)
    if n == 0
      return 1
    else
      return n * factorial(n-1)
    end
  end
  
#   puts factorial(5)  # 输出 120

#   以计算阶乘 5! 为例，假设系统栈是一个可以存储数据的空间，递归调用栈的过程可以如下图所示：
#   +---------------------+
#   |         ...         |
#   +---------------------+
#   |    factorial(2)     |
#   +---------------------+
#   |    factorial(3)     |
#   +---------------------+
#   |    factorial(4)     |
#   +---------------------+
#   |    factorial(5)     |
#   +---------------------+

#   首先，调用 factorial(5) 函数，将 5 作为参数传入。由于 5 不等于 0，函数内部调用 factorial(4) 并将 4 作为参数传入。由于 4 不等于 0，函数继续调用 factorial(3) 并将 3 作为参数传入。以此类推，递归调用栈会不断深入，直到调用 factorial(0)。

# 在调用 factorial(0) 后，由于 0 等于 0，满足终止条件，返回值 1 被压入栈顶。此时，系统栈如下所示：

# +---------------------+
# |         ...         |
# +---------------------+
# |    factorial(2)     |
# +---------------------+
# |    factorial(3)     |
# +---------------------+
# |    factorial(4)     |
# +---------------------+
# |    factorial(5)     |
# +---------------------+
# |          1          |
# +---------------------+
# 接下来，每次递归函数返回时，栈顶的返回值被弹出并用于计算前一个递归函数的结果。例如，调用 factorial(1) 函数时，返回值为 1，会用于计算 2!。计算完 2! 后，返回值 2 被压入栈顶。系统栈如下所示：

# +---------------------+
# |         ...         |
# +---------------------+
# |    factorial(3)     |
# +---------------------+
# |    factorial(4)     |
# +---------------------+
# |    factorial(5)     |
# +---------------------+
# |          2          |
# +---------------------+

# 最终，当所有的递归函数都返回并计算完毕后，最终结果被保存在栈顶。系统栈如下所示：

# +---------------------+
# |         ...         |
# +---------------------+
# |    factorial(5)     |
# +---------------------+
# |        120          |
# +---------------------+
